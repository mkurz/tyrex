<?xml version="1.0"?>
<!-- $Id: using.xml,v 1.3 2001/03/20 19:29:08 arkin Exp $ -->
<document>
  <properties>
    <title>Using Tyrex</title>
    <author email="arkin@intalio.com">Assaf Arkin</author>
  </properties>

  <body>

    <section title="Transaction Domains">
      
      <p>A <api>tyrex.tm.TransactionDomain</api> provides centralized management for transactions.
        A transaction domain defines the policy for all transactions created from that domain,
        such as default timeout, maximum number of open transactions, IIOP support, and journaling.
        In addition, the domain maintains resource managers such as JDBC data sources and JCA
        connectors.</p>
      
      <p>The application server obtains the transaction manager, user transaction and transaction
        factory from the transaction domain. It also uses the transaction domain to obtain
        connection factories and place them in the JNDI Environment Naming Context.</p>

      <p>Transaction domains are created from domain configuration files. The structure and
        values of the domain configuration file is specified in <a href="configuration.html">Tyrex
          Configuration</a>.</p>

      <p>The following example illustrates how to create a new transaction domain from the
        domain configuration file <tt>domain.xml</tt> located in the current directory:
        <code>
TransactionDomain domain;

<comment>// Create a transaction domain using
// a domain configuration file</comment>
try {
    domain = TransactionDomain.createDomain( "domain.xml" );
} catch ( DomainConfigurationException except ) {
    <comment>// Domain cannot be created, handle error</comment>
    . . . 
}
<comment>// Recover all resources used in the domain</comment>
try {
    domain.recover();
} catch ( RecoveryException except ) {
    while ( except != null ) {
        System.out.println( "Recovery error: " + except );
        except = except.getNextException();
    }
}
<comment>// Domain is now active and ready for use</comment>
        </code></p>
      
    </section>


    <section title="Resources">

      <p>The object <api>tyrex.resource.Resources</api> represents a collection of installed
        resources managers. Resources, such as JDBC data sources and JCA connectors, are
        configured based on their specification in the domain configuration file. In addition,
        resources can be added and removed at run-time.</p>

      <p>Each resource manager is represented by an object of type <api>tyrex.resource.Resource</api>.
        Each such object represents a single installed resource. The application server uses
        these objects to interact with the resource manager, and expose the resource manager
        to the client application.</p>

      <p>An installed resource has a client factory that is exposed to the application from
        the JNDI Environment Naming Context. The client factory type depends on the resource
        type, e.g. a JDBC <tt>DataSource</tt>, a JCA CCI <tt>ConnectionFactory</tt>, etc.</p>

      <p>An installed resource has a connection pool that manages utilization of connections.
        The connection pool is not directly accessible to the application, but the usage
        metrics are accessible from <api>tyrex.resource.PoolMetrics</api>. Usage metrics
        includes such information as the number of connections created and released over
        a period of time, average duration for using or holding a connection in the pool, etc.</p>

      <p><api>tyrex.resource.ResourceLimits</api> represents limits placed on the connection
        pool. These limits restrict the maximum number of connections that can be used at
        any one time, define the minimum number of connections to retain in the pool, the
        duration for retaining connections in the pool between uses, and more.</p>

    </section>
    

    <section title="The Runtime Context">

      <p>The <api class="tyrex.tm.RuntimeContext">runtime context</api> provides an association
        between a component or client, the current thread, and resources used by the application.</p>
      
      <p>The runtime context keeps track of active transaction, JNDI ENC, security subject, and open
        connections. It is associated with a component or client, and can be preserved across method
        invocations by associating it with the current thread.</p>
      
      <p>Each thread is associated with a runtime context, whether explicitly or implicitly. A thread can
        be associated with a particular runtime context by calling <tt>setRuntimeContext()</tt>.
        If this method was not called, a default runtime context is created on demand.</p>
      
      <p>A new runtime context can be created with one of the <tt>newRuntimeContext()</tt> methods and
        populated with JNDI bindings and security context. The runtime context is then associated with
        the current thread across method invocations belonging to the same component or client.</p>

      <p>The runtime context keeps track of the current active transaction. When the runtime context
        is associated with the current thread, this is the same transaction available from
        <tt>TransactionManager</tt>.</p>

      <p>The runtime context keeps track of the JNDI environment naming context. The JNDI bindings are accessible
        from the <tt>java:</tt> URL when the runtime context is associated with the current thread.</p>
      
      <p>The runtime context keeps track of the security subject used for authentication and authorization when
        the runtime context is associated with the current thread.</p>
      
      <p>The runtime context keeps track of all connections obtained from the environment naming context.
        Open connections can be retained across method invocations.</p>
      
      <p>The following example illustrates how to create and use a runtime context:
        <code>
RuntimeContext runCtx;
Context        jndiCtx;
Resources      resources;
DataSource     dataSource;

<comment>// Create a new context</comment>
runCtx = RuntimeContext.newRuntimeContext();

<comment>// Create the context 'comp/env/jdbc'</comment>
jndiCtx = runCtx.getEnvContext();
jndiCtx = jndiCtx.createSubcontext( "comp" );
jndiCtx = jndiCtx.createSubcontext( "env" );
jndiCtx = jndiCtx.createSubcontext( "jdbc" );

<comment>// Obtain resources from the transaction domain
// Obtain the client factory for 'db1'</comment>
resources = TransactionDomain.getDomain( "myDomain" ).
    getResources();
dataSource = (DataSource) resources.getResource( "db1" );
<comment>// Bind 'db1' as 'comp/env/jdbc/myDb'</comment>
jndiCtx.bind( "myDb", dataSource );

. . .
<comment>// Associate the runtime context with
// the current thread</comment>
RuntimeContext.setRuntimeContext( runCtx );

. . .
<comment>// Dissociate the runtime context with
// the current thread</comment>
RuntimeContext.unsetRuntimeContext();

. . .
<comment>// Discard the runtime context</comment>
runCtx.cleanup();
        </code></p>

      <p><code>
InitialContext initCtx;
String         jndiName;
DataSource     dataSource;
Connection     conn;

<comment>// Application code to access the database</comment>
initCtx = new InitialContext();
jndiName = "java:comp/env/jdbc/myDb";
dataSource = (DataSource) initCtx.lookup( jndiName );
conn = dataSource.getConnection();
        </code></p>

    </section>


    <section title="JTA Extended Interfaces">

      <p>All Tyrex transactions implement the interface <api>tyrex.tm.TyrexTransaction</api>,
        which supports asynchronous commit and rollback, and one phase commit.</p>

      <p>All Tyrex transaction managed implement the interface <api>tyrex.tm.TyrexTransactionManager</api>,
        which supports transaction resolving from an Xid, and means to obtain extended transaction
        status.</p>
      
      <p><api>tyrex.tm.TransactionStatus</api> provide additional information about a
        transaction in addition to that provided by <tt>Transaction</tt>, including the transaction
        identifier (Xid), start time and timeout, resources and thread association.</p>

      <p>Interceptors allow an external engine to hook up into the transaction monitor and either record
        the outcome of transactions or affect them. The interceptor is notified when transactions are
        created, attempt to commit, rolled back, and when they are resumed or suspended from threads.</p>

    </section>


  </body>
</document>
