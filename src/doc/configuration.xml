<?xml version="1.0"?>
<!-- $Id: configuration.xml,v 1.5 2001/03/19 22:16:24 arkin Exp $ -->
<document>
  <properties>
    <title>Tyrex Configuration</title>
    <author email="arkin@intalio.com">Assaf Arkin</author>
  </properties>

  <body>

    <section title="Configuration File">

      <p>When Tyrex is instantiated, it reads configuration properties from the Tyrex
       configuration file. The Tyrex configuration file is called <tt>tyrex.config</tt>.</p>

      <p>The configuration file is loaded in the following manner. First, a default
        configuration file is loaded from the Tyrex JAR. This file provides the minimum
        set of default values required by Tyrex, including such data as the version number.</p>

      <p>If a configuration file called <tt>tyrex.config</tt> exists in the class path,
        it will be loaded next. This file can override any values specified in the default
        configuration file.</p>

      <p>The name of the configuration file can be specified using the system property
        <tt>tyrex.config</tt>. The following example illustrates how to set the system
        property:
        <code><![CDATA[
java -Dtyrex.config=tyrex.config $1 ]]></code></p>        

      <p>The following properties are supported in the current version of Tyrex:
        <ul>
          <li><b><tt>tyrex.log.verbose</tt></b> Specifies whether to run Tyrex in verbose
            mode. When this property is set to <tt>true</tt>, Tyrex will emit additional
            information to the log to assist in troubleshtooting and debugging. It is
            recommended to leave this property to the default value (<tt>false</tt>)
            in a deployment environment.</li>
          <li><b><tt>tyrex.log.console</tt></b> Specifies whether to enable console logging.
            When this property is set to <tt>true</tt> (the default), Tyrex will emit
            various information (in both verbose and non-verbose mode) to the console.</li>
          <li><b><tt>tyrex.clock.unsynchTicks</tt></b> Determines the number of clocks ticks
            to skip before incrementing the internal clock. The value of this property is
            an integer, the precision is milliseconds. The default value is <tt>100</tt>
            milliseconds.</li>
          <li><b><tt>tyrex.clock.synchEvery</tt></b> Determines the number of unsynchronized
            cycles before synchronizing the clock. The value of this property is an integer
            that, when multiplied by <tt>tyrex.clock.unsynchTicks</tt>, determines the clock
            synchronization interval (in milliseconds). The default value is <tt>10</tt>
            cycles.</li>
          <li><b><tt>tyrex.random.secure</tt></b> Determines whether to use secure
            (cryptographic quality) or standard (pseudo) random number generator. Setting this
            property to <tt>true</tt> assures that random numbers are truely random, but
            results in a longer statup sequence. The default value is <tt>false</tt>.</li>
          <li><b><tt>tyrex.uuid.stateFile</tt></b> The name of the UUID state file, see
            <a href="#UUID State File">UUID State File</a> for more information. The default
            value is <tt>uuid.state</tt>.</li>
          <li><b><tt>tyrex.domain.files</tt></b> Specifies the name of the default domain
            configuration file(s). This property is a list of file names that must be
            accessible from the current directory. All domain configuration files specified
            in this property will be loaded automatically by Tyrex. If this property is missing,
            Tyrex loads up with no transaction domain.</li>
        </ul></p>

      <p>The following example illustrates a Tyrex configuration file:
        <code><![CDATA[
tyrex.log.verbose=false
tyrex.log.console=true

tyrex.clock.unsynchTicks=100
tyrex.clock.synchEvery=10
tyrex.random.secure=true
tyrex.uuid.stateFile=uuid.state
tyrex.domain.files=domain.xml ]]></code></p>

    </section>


    <section title="UUID State">

      <p>The Tyrex UUID generator is used for producing Universally Unique IDentifiers.
        UUIDs are 128 bit values guaranteed to be unique across all servers and applications.
        They are used for transaction identifiers, and by applications that rely on this
        service to produce unique identifiers.</p>

      <p>In order to guarantee uniqueness, the UUID generator utilizes three parameters:
        the system clock, clock sequence and node identifier. The system clock simulates
        a resolution of 100 nanoseconds, allowing nearly ten thousand UUIDs to be generated
        in a second.</p>

      <p>The <i>clock sequence</i> protects against a retarding clock. The clock may be set
        backwards accidentaly. or as a result of server down time. Day light savings time has
        no effect on the clock, but clustered servers will seldom have a synchronized clock.
        The clock sequence is automatically incremented each time Tyrex is started, rolling
        over after 8192 restarts.</p>
      
      <p>The <i>node identifier</i> guarantees uniqueness across servers. The node idenifier
        if a 47 bit value set from the IEEE 802 address of the network card. Each network card
        has a universally unique 47 bit identifier. Where multiple network cards are installed,
        any one card can be used.</p>

      <p>When installing Tyrex for the first time, the network card address is obtained and
        placed in the UUID state file. To obtain the network address under Linux/UNIX, run
        <tt>ifconfig</tt> from the root account. To obtain the network card address under
        Windows 2000, open a DOS window and type <tt>ipconfig /all</tt>.</p>

      <p>The clock sequence can be set to any arbitrary value between 0 and 8192, but must
        have no correlation with the network card address to be unique. If no value is placed,
        the initial value will be randomly generated.</p>

      <p>The following example illustrates the contents of a UUID state file generated from
        the network card address <tt>08:00:46:08:64:C3</tt> with a clock sequence of 100. 
      <code>
uuid.nodeIdentifier=08:00:46:08:64:C3
uuid.clockSequence=100</code></p>

      <p>The UUID state file is typically located in the installation directory of Tyrex,
        under the name <tt>uuid.state</tt>. The location and name of the file can be
        controlled using the configuration property <tt>tyrex.uuid.stateFile</tt>.</p>

      <p>If the UUID state file could not be located, Tyrex will use random values for
        both the node identifier and clock sequence. Different random values will be
        generated each time Tyrex is used to assure uniquness. In a deployment environment
        it is important to gurantee that both values are truely unique. If the network
        card address is unavailable, use cryptographic quality random number generator by
        setting the configuration property <tt>tyrex.random.secure</tt> to true.</p>
      
      <p>Using the cryptographic quality random number generator will slow the initialization
        process. It is recommended to leave this property unset in a development environment.</p>
      
    </section>


    <section title="Domain Configuration">

      <p>A transaction domain provides centralized management for transactions. A transaction
        domain defines the policy for all transactions created from that domain, such as default
        timeout, maximum number of open transactions, IIOP support, and journaling.</p>

      <p>The transaction manager and user transaction (JTA), and the transaction factory and
        IIOP server (OTS) are obtained from the transaction domain. Multiple transaction domains
        can exist in the same JVM, e.g. to allow application partitioning.</p>

      <p>A transaction domain is created from a domain configuration file. The domain configuration
        file defines all the properties of the transaction domain. In addition, it is used to
        configure all the resource managers (JDBC, JCA, etc) available to applications using this
        transaction domain.</p>

      <p>Applications do not interact with transaction domains directly. Transaction domains are
        created and managed by the application server or some other application framework.
        The application accesses the user transaction, current thread context, and connection
        factories through JNDI. The application server or application framework are responsible
        to place these objects in the application's JNDI environment naming context (ENC).</p>

      <p>In order to use a transaction domain, the application server must first create it using
        <javadoc>tyrex.tm.TransactionDomain</javadoc>. The application can also obtain a previously
        created transaction domain, or one created automatically based on the <tt>tyrex.domain.file</tt>
        configuration file property.</p>

      <p>The transaction domain configuration file is a standard XML document with the following structure:</p>

      <h4>domain</h4>

      <p>The top level element <tt>domain</tt> provides the configuration of the transaction domain.
        A domain configuration file can only define a single transaction domain.</p>

      <h4>domain/name</h4>

      <p>Each transaction domain must have a unique name. Tyrex does not allow two transaction
        domains to be configured with the same name. The domain name is used for logging of errors
        and other informative messages, and should be kept short.</p>

      <h4>domain/maximum</h4>

      <p>Specifies the maximum number of active transactions supported by this domain. If the
        application attempts to begin a transaction when this limit has been reached it will
        be blocked until at least one active transaction has committed or rolled back.</p>

      <p>If this element is missing, the default value (zero) is used, meaning no limit on the
        number of concurrent active transactions.</p>

      <h4>domain/timeout</h4>

      <p>Specifies the default timeout for all transactions. All transactions are subject to
        a timeout to prevent deadlocks and other race conditions from blocking an application
        indefinitely.</p>

      <p>The timeout for a transaction can be changed at runtime. In addition, <tt>TransactionManager</tt>
        allows the timeout of new transactions to be changed to any other value, or reset
        back to the default value.</p>

      <p>If this element is missing, the default (120 seconds) is used. It is recommended to
        set this value to a reasonable range that allows all transactions to complete, but
        prevents blocked transactions for waiting indefinitely.</p>

      <h4>domain/threads</h4>

      <p>Specifies the number of threads in the thread pool. The thread pool is an optional
        service that can be used by application developers. The thread pool is created with
        a default thread capacity.</p>

      <p>If this element is missing, the default (no threads) is used. Consult the
        <javadoc>tyrex.services.ThreadPool</javadoc> Javadocs for more details.</p>

      <h4>domain/journalFactory</h4>

      <p>Specifies the transaction journal factory to use. The transaction journal is used to
        enable transaction recovery through a journaling mechanism. This element provides the
        class name for a factory that implements the <javadoc>tyrex.tm.JournalFactory</javadoc>
        interface.</p>

      <p>If this element is missing, journaling is not supported by the domain.</p>

      <h4>domain/resources</h4>

      <p>Provides configuration for resource managers (JDBC, JCA, etc) that are available
        from this transaction domain.</p>

      <p>Resource managers must be configured from within a transaction domain to allow
        them to be managed by the transaction manager, and automatically enlisted in
        transactions.</p>

      <p>The <tt>resources</tt> element includes a list of zero or more resource configuration
        elements. Order is not important. After the domain has been created the resources
        can be obtained from <javadoc>tyrex.tm.TransactionDomain</javadoc> and listed in the
        JNDI environment naming context. It's possible to add/remove resources at run time
        to enable hot-deployment of databases and connectors.</p>

      <h4>resources/dataSource</h4>

      <p>The <tt>dataSource</tt> element configures a JDBC 2.0 (or 3.0) <tt>DataSource</tt>
        as a resource manager. This element configures the database access properties,
        and the connection pool limits.</p>

      <h4>resources/connector</h4>

      <p>The <tt>connector</tt> element configures a JCA 1.0 <tt>ResourceAdapter</tt> as
        a resource manager. This element configures the connector access properties, the
        and connection pool limits.</p>

      <h4>[dataSource|connector]/name</h4>

      <p>Specifies the name by which the data source or connector will be known. The
        <javadoc>tyrex.resource.Resource</javadoc> object can be obtained by this name.
        The name must be unique within a transaction domain. There is no requirement to
        enlist the resource in JNDI with this specific name.</p>

      <h4>[dataSource|connector]/jar</h4>

      <p>Provides the file name or URL where the data source or connector JAR can be found.
        Explicitly naming the JAR allows data sources and connectors to be located in a
        separate directory than the one used by Tyrex or the application. Only a single JAR
        can be specified. This must be the main JAR holding the JDBC driver or JCA connector.</p>

      <h4>[dataSource|connector]/paths</h4>

      <p>If the data source or connector require additional JARs, libraries or other files,
        these are specified using the optional <tt>paths</tt> element. This element works
        like a Java class path and includes a colon or semi-colon separate list of files
        and directories.</p>

      <h4>dataSource/class</h4>

      <p>The class of the data source implementation must be specified explicitly. For JCA
        connector, the classes are read from the JCA deployment descriptor (<tt>ra.xml</tt>).
        When using an XA-capable data source, this should be the class implementing
        <tt>javax.sql.XADataSource</tt>. When using non-XA capable, poolable, data sources,
        this should be the class implementing <tt>javax.sql.PoolConnectionDataSource</tt>.
        Otherwise, it should be a class implementing <tt>javax.sql.DataSource</tt>.</p>

      <h4>[dataSource|connector]/config</h4>

      <p>Defines configuration for the data source or connector. This element contains
        a list of nested element that match the data source or connector configuration
        properties. The configuration properties are read from this element and set using
        the respective <tt>set</tt> method.</p>

      <p>For example, for a <tt>DataSource</tt> that has the methods <tt>setHostName</tt>
        and <tt>setUser</tt>, use:<code>
&lt;config&gt;
  &lt;hostName&gt;host.domain.com&lt;/hostName&gt;
  &lt;user&gt;myself&lt;/user&gt;
&lt;/config&gt;</code></p>

      <h4>[dataSource|connector]/limits</h4>

      <p>Defines the limits of the connection pool. If this element is missing or is empty,
        the default limits are used.</p>

      <h4>limits/maximum</h4>

      <p>The maximum number of open connections allowed. When this limit is reached, the
        application will block until a connection becomes available or a timeout occurs.
        Most systems impose a limit on the maximum number of connections that can be used.
        Setting the pool limit allows Tyrex to block requests for new connections until
        the pool is able to respond (see also <tt>timeout</tt>), instead of throwing
        an exception.</p>

      <p>If this element is missing, the default (zero) will be used, implying that no
        limit is placed on the size of the connection pool.</p>

      <h4>limits/minimum</h4>

      <p>The minimum number of open connections to retain. When a connection is released
        by the application and returned to the pool, the pool is allowed to close the
        connection. The connection pool will retain an unused connection for some
        maximum time (see <tt>maxRetain</tt>) before discarding it.</p>

      <p>The connection pool will maintain the minimum number of connections specified,
        even if they have been retained longer than <tt>maxRetain</tt> to guarantee
        a reasonable response time when new connections are required.</p>

      <p>If this element is missing, the default (zero) will be used, implying no
        connections need to be retained past the maximum retain duration.</p>

      <h4>limits/initial</h4>

      <p>The initial number of connections to create. When the connection pool is opened,
        it contains exactly one connection (required for recovery and meta-data access).
        The <tt>minimum</tt> element tells the connection pool how many connections to
        keep in the pool, but does not indicate that it should create that number of
        connections. The <tt>initial</tt> element can be used to request an initial set
        of connections to exist in the pool.</p>

      <p>If this element is missing, the default (zero) will be used, and the connection
        pool will not attempt to create any connections.</p>

      <h4>limits/maxRetain</h4>

      <p>The maximum time (in seconds) to retain an unused connection. When a connection
        is returned to the pool by the application, it will be retained for that duration
        before being discarded. The connection pool assumes that the connection might be
        reused by the application within that duration, hence will not discard it
        immediately.</p>

      <p>When specifying this value, take into consideration any idle timeout on connections,
        and the requirements of applications running outside this transaction domain.
        If the connector has an idle timeout on connections, the maximum retain duration
        must be less than or equal to the idle timeout.</p>

      <p>A high retain time allows the application to respond better to changing loads,
        by retaining a large number of open connections over consecutive peak demand.
        However, a high retain time might cause starvation to applications running outside
        this transaction domain.</p>

      <p>If this element is missing, the default (zero) will be used, allowing connections
        to be kept in the pool forever.</p>

      <h4>limits/timeout</h4>

      <p>The timeout (in seconds) waiting for a new connection. If the maximum limit has
        been reached, Tyrex will block the application until a connection becomes available
        or the timeout has been reached.</p>

      <p>Setting the timeout value allows the application to deal better with peak loads by
        blocking temporarily, instead of ending with an exception. A large value, however,
        will not save the application from resource starvation.</p>

      <p>If this element is missing, the default (zero) will be used, meaning the application
        will not be blocked and an exception will be thrown if the maximum limit has been
        reached.</p>

      <h4>limits/trace</h4>

      <p>Requests tracing for the data source or connector. If this element is true,
        Tyrex will provide a log writer to the data source or connector, which they can use
        to print trace messages.</p>
        
      <h4>Example</h4>

      <p>The following example illustrates a domain configuration file using Sybase jConnect 5.2:</p>
        <code>
&lt;domain&gt;
  &lt;name&gt;default&lt;/name&gt;
  &lt;!-- Limit to 50 concurrent transactions --&gt;
  &lt;maximum&gt;50&lt;/maximum&gt;
  &lt;!-- Default transaction timeout: 2 minuts --&gt;
  &lt;timeout&gt;120&lt;/timeout&gt;
  &lt;resources&gt;
    &lt;dataSource&gt;
      &lt;name&gt;myDb&lt;/name&gt;
      &lt;jar&gt;jconnect_5.2.jar&lt;/jar&gt;
      &lt;class&gt;com.sybase.jdbc2.jdbc.SybXADataSource&lt;/class&gt;
      &lt;config&gt;
        &lt;!-- Properties defined by SybXADataSource --&gt;
        &lt;user&gt;arkin&lt;/user&gt;
        &lt;password&gt;secret&lt;/password&gt;
        &lt;serverName>tyrex.exolab.org&lt;/serverName&gt;
        &lt;postNumber&gt;4100&lt;/portNumber&gt;
      &lt;/config&gt;
      &lt;limits&gt;
        &lt;!-- Start with 5 connections, never go below 5,
             and never go above 50 --&gt;
        &lt;maximum&gt;50&lt;/maximum&gt;
        &lt;minimum&gt;5&lt;/minimum&gt;
        &lt;initial&gt;5&lt;/initial&gt;
        &lt;!-- Discard connections after 5 idle minutes --&gt;
        &lt;maxRetain&gt;300&lt;/maxRetain&gt;
        &lt;!-- If maximum reached, block for 10 seconds --&gt;
        &lt;timeout&gt;10&lt;/timeout&gt;
      &lt;/limits&gt;
    &lt;/dataSource&gt;
  &lt;/resources&gt;
&lt;/domain&gt;</code> 

    </section>
    
    
  </body>
</document>
