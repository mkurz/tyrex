/**
 * Redistribution and use of this software and associated documentation
 * ("Software"), with or without modification, are permitted provided
 * that the following conditions are met:
 *
 * 1. Redistributions of source code must retain copyright
 *    statements and notices.  Redistributions must also contain a
 *    copy of this document.
 *
 * 2. Redistributions in binary form must reproduce the
 *    above copyright notice, this list of conditions and the
 *    following disclaimer in the documentation and/or other
 *    materials provided with the distribution.
 *
 * 3. The name "Exolab" must not be used to endorse or promote
 *    products derived from this Software without prior written
 *    permission of Intalio.  For written permission,
 *    please contact info@exolab.org.
 *
 * 4. Products derived from this Software may not be called "Exolab"
 *    nor may "Exolab" appear in their names without prior written
 *    permission of Intalio. Exolab is a registered
 *    trademark of Intalio.
 *
 * 5. Due credit should be given to the Exolab Project
 *    (http://www.exolab.org/).
 *
 * THIS SOFTWARE IS PROVIDED BY INTALIO AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT
 * NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * INTALIO OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Copyright 2000 (C) Intalio Inc. All Rights Reserved.
 *
 */


package tyrex.connector.manager;

import java.io.PrintWriter;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.transaction.RollbackException;
import javax.transaction.Status;
import javax.transaction.Synchronization;
import javax.transaction.SystemException;
import javax.transaction.Transaction;
import javax.transaction.xa.XAResource;
import tyrex.connector.ConnectionException;
import tyrex.connector.ManagedConnection;
import tyrex.util.Messages;

///////////////////////////////////////////////////////////////////////////////
// ManagedConnectionPoolImpl
///////////////////////////////////////////////////////////////////////////////

/**
 * Implementation of ManagedConnectionPool. The check that all the managed 
 * connections in the pool come from the same managed connection
 * factory is not enforced. This class is not thread-safe. It assumes that
 * it is made thread-safe by the class that uses it.
 *
 *
 * @author <a href="mohammed@intalio.com">Riad Mohammed</a>
 */
public final class ManagedConnectionPoolImpl implements ManagedConnectionPool
{
    /**
     * The pool of available managed connections.
     */                
    // vector is used because an enumeration of the elements 
    // needs to be returned. The alternative would be to use
    // an arraylist and create an enumeration wrapper for the
    // iterator. I have not performed any tests but I feel that
    // the object creation of the enumeration outweighs the extra
    // synchronization costs
    //TODO test this hypothesis
    private final Vector pool = new Vector();

    /**
     * Holds a list of all the active resources that are being
     * used by the application. Each resource is held inside
     * an {@link ManagedEntry} that records the resource's
     * account, using {@link tyrex.connector.ManagedConnection} as the key.
     */
    // hashtable is used because an enumeration of the keys 
    // needs to be returned. The alternative would be to use
    // a hashmap and create an enumeration wrapper for the
    // iterator for the keyset. I have not performed any tests 
    // but I feel that the object creation of the enumeration and keyset
    // outweighs the extra synchronization costs
    //TODO test this hypothesis
    private final Hashtable active = new Hashtable();

    /**
     * The log writer. Can be null.
     */
    private PrintWriter logWriter;

    /**
     * The description of the pool. Can be null.
     */
    private String description;

    /**
     * Create the ManagedConnectionPoolImpl.
     *
     */
    public ManagedConnectionPoolImpl()
    {
    }

    /**
     * Called by the resource pool manager to obtain the number of pooled
     * resources. Pooled resources are not being used currently,
     * and may be available to a requesting caller.
     *
     * @return The number of pooled resources
     */ 
    public int getPooledCount()
    {
        return pool.size();
    }


    /**
     * Called by the pool manager to obtain the number of active
     * resources. Active resources are those that are currently in
     * used, and subject to the active upper limit.
     *
     * @return The number of active resources
     */
    public int getActiveCount()
    {
        return active.size();
    }

    /**
     * Return the printed representation of the connection 
     * resource pool.
     *
     * @return the printed representation of the connection
     *      resource pool.
     */
    public String toString()
    {
        return  super.toString() + "[" + 
                (null == description ? "" : description) + 
                "]";
    }


    /**
     * Called by the resource pool manager when it determines that a certain
     * number of resources should be released from the pool.
     * Active resources are never asked to be removed. The pool
     * may remove any number of resources it sees fit.
     * <BR>
     * The managed connections are automatically closed when they
     * are released from the pool.
     *
     * @param count The number of pooled resources that should be
     *   released
     */
    public synchronized void releasePooled(int count)
    {
        for ( int i = 0 ; i < count && i < pool.size() ; ++i ) {
            ManagedConnection managedConnection = (ManagedConnection) pool.get(0);
            pool.remove(0);
            try {
                managedConnection.close();
            } 
            catch (ConnectionException e) {
                if (null != logWriter)
                    logWriter.println( Messages.format("tyrex.resource.fault", toString(), managedConnection, e));
            }
        }
    }

    /**
     * Get the log writer associated with the ManagedConnectionPool.
     * can be null.
     *
     * @return the log writer associated with the ManagedConnectionPool.
     */
    public PrintWriter getLogWriter()
    {
        return logWriter;
    }


    /**
     * Set the log writer associated with the ManagedConnectionPool.
     *
     * @param logWriter the new log writer. Can be null.
     */
    public void setLogWriter(PrintWriter logWriter)
    {
        this.logWriter = logWriter;
    }
        

    /**
     * Return the description of the ManagedConnectionPool.
     * Can be null.
     *
     * @return the description of the ManagedConnectionPool.
     */
    public String getDescription()
    {
        return description;
    }


    /**
     * Set the description of the ManagedConnectionPool.
     *
     * @param description the new description of the ManagedConnectionPool.
     *      Can be null.
     */
    public void setDescription(String description)
    {
        this.description = description;
    }


    /**
     * Return the enumeration containing the active managed 
     * connections in the pool.
     *
     * @return the enumeration containing the active managed
     *      connections in the pool.
     */
    public Enumeration getActiveConnections()
    {
        return active.keys();
    }

    /**
     * Return the enumeration containing the pooled managed 
     * connections.
     *
     * @return the enumeration containing the pooled managed
     *      connections.
     */
    public Enumeration getPooledConnections()
    {
        return pool.elements();
    }

    /**
     * Remove the specified managed connection from the pool.
     *
     * @param managedConnection the managed connection to be
     *      removed from the pool
     */
    public void unpool(ManagedConnection managedConnection)
    {
        pool.remove(managedConnection);
    }


    /**
     * delist the specified managed resource in the specified 
     * transaction. Both arguments are assumed NOT to be null.
     *
     * @param managedConnection the managed connection to be enlisted
     * @param transaction the transaction
     * @throws ConnectionException if there is a problem delisting 
     *      the managed connection.
     */
    private void delist(ManagedConnection managedConnection, 
                        Transaction transaction,
                        int flag)
        throws ConnectionException
    {

        try {
            // if we can delist from the transaction
            if ((transaction.getStatus() == Status.STATUS_ACTIVE) || 
                (transaction.getStatus() == Status.STATUS_MARKED_ROLLBACK)) {
                // get xa resource associated with the connection
                XAResource xaResource = managedConnection.getXAResource();
                if ((null != xaResource) &&
                    !transaction.delistResource(xaResource, flag)) {
                    throw new ConnectionException("Failed to delist xa resource for <" + 
                                                  managedConnection + 
                                                  "> in the current transaction.");
                }
            }
        }
        catch (SystemException e) {
            throw new ConnectionException("Error in transaction manager", e);
        }
    }
    

    /**
     * Enlist the specified managed resource in the specified 
     * transaction. Both arguments are assumed NOT to be null.
     *
     * @param managedConnection the managed connection to be enlisted
     * @param transaction the transaction
     * @throws ConnectionException if there is a problem enlisting 
     *      the managed connection.
     */
    private void enlist(ManagedConnection managedConnection, Transaction transaction)
        throws ConnectionException
    {
        // get xa resource associated with the connection
        XAResource xaResource = managedConnection.getXAResource();
        //System.out.println("use " + managedConnection + " trans " + transaction + " xa " + xaResource);
        if (null != xaResource) {
            try {
                // enlist the resource
                if (!transaction.enlistResource(xaResource)) {
                    throw new ConnectionException("Failed to enlist xa resource for <" + 
                                                  managedConnection + 
                                                  "> in the current transaction.");
                }
                //System.out.println("enlisted");
            }
            catch (RollbackException e) {
                throw new ConnectionException("The transaction has been marked for rollback", e); 
            }
            catch (SystemException e) {
                throw new ConnectionException("Error in transaction manager", e);
            }
        }
        else {
            throw new ConnectionException("Managed connection <" + managedConnection + " has no XA resource.");
        }
    }


    /**
     * The specified managed connection is to be used externally
     * in the specified transaction. 
     * <BR>
     * The managed connection is enlisted in the transaction if
     * the managed connection is new.
     *
     * @param managedConnection the managed connection that may
     *      or may not already be active. However it is assumed
     *      that the connection is not pooled.    
     * @param transaction the transaction to be associated with
     *      the specified transaction. Can be null.
     * @throws ConnectionException if the managed connection is shared
     *      and the existing transaction is not the same as the
     *      specified transaction
     */
    public void use(ManagedConnection managedConnection, Transaction transaction)
        throws ConnectionException
    {
        // get the managed connection entry
        ManagedConnectionEntry entry = (ManagedConnectionEntry)active.get(managedConnection);

        if (null == entry) {
            // add the entry before enlisting so that an exceptions during
            // enlisting cause discard to work properly
            try {
                entry = new ManagedConnectionEntry(managedConnection, transaction);
            }
            catch (Exception e) {
                throw new ConnectionException("Failed to associate the managed connection with the transaction",
                                              e);
            }
            active.put(managedConnection, entry);

            // enlist the managed connection
            if (null != transaction) {
                enlist(managedConnection, transaction);
            }
        }
        else if ((entry.refCount > 0) && (transaction != entry.transaction)) {
            throw new ConnectionException("The existing transaction <" + 
                                          entry.transaction +
                                          "> of the shared managed connection <" +
                                          managedConnection +
                                          "> is not the same as the specified transaction <" +
                                          transaction +
                                          ">.");
        }
        
        // tell the entry that the connection is used
        ++entry.refCount;
    }


    /**
     * Return the transaction associated with the active managed connection.
     *
     * @return the transaction associated with the active managed connection.
     */
    public Transaction getTransaction(ManagedConnection managedConnection)
    {
        // get the managed connection entry
        ManagedConnectionEntry entry = (ManagedConnectionEntry)active.get(managedConnection);

        if (null != entry) {
            return entry.transaction;    
        }
        else if (null != logWriter) {
            logWriter.println( "Internal error: Cannot find the managed entry for the specified managed connection <" +
                               managedConnection +
                               "> while trying to get the transaction associated with the managed connection " +
                               "(ManagedConnectionPoolImpl#getTransaction).");
        }

        return null;
    }

    /**
     * The specified managed connection has been closed externally.
     * If the managed connection is not shared put the connection
     * back into the pool so that it can be used.
     * <BR>
     * If the managed connection is enlisted in a transaction it is
     * automatically delisted.
     *
     * @param managedConnection the managed connection that is no 
     *      longer used externally.
     * @return True if the managed connection has been returned to the pool
     * @throws ConnectionException if there is a problem returning the managed
     * connection to the pool
     */
    public boolean unuse(ManagedConnection managedConnection)
        throws ConnectionException
    {
        // get the managed connection entry
        ManagedConnectionEntry entry = (ManagedConnectionEntry)active.get(managedConnection);

        if (null != entry) {
            --entry.refCount;

            // not shared
            if (0 == entry.refCount) {
                // in case the transaction for the entry
                // is changed out from under us 
                synchronized (entry) {
                    // delist the managed connection
                    if (null != entry.transaction) {
                        try {
                            delist(managedConnection, 
                                    entry.transaction,
                                    XAResource.TMSUCCESS);
                        }
                        finally {
                            // reset the entry transaction so that
                            // discard does not try to delist again
                            entry.resetTransaction();
                        }
                    }
                }
                // remove from the active
                active.remove(managedConnection);
                //TODO recycle entries?
                // add to the pool
                pool.add(entry.managedConnection);
                // the connection has been return to the pool
                return true;
            }
            // the connection is being shared
            return false;
        }
        else if (null != logWriter) {
            logWriter.println( "Internal error: Cannot find the managed entry for the specified managed connection <" +
                               managedConnection +
                               "> while trying to return the managed connection to the pool " +
                               "(ManagedConnectionPoolImpl#unuse).");
        }

        return false;
    }

    /**
     * The specified managed connection should be discarded from tbe
     * resource pool because an error occurred while it was being used.
     * The managed connection is automatically closed by this method.
     * <BR>
     * If the managed connection is enlisted in a transaction it is
     * automatically delisted.
     *
     * @param managedConnection the managed connection that is
     * longer valid.
     * @throws ConnectionException if there is a problem discarding the
     *      managed connection.
     */
    public void discard(ManagedConnection managedConnection)
        throws ConnectionException
    {
        try {
            // it should not be in the pooled connections but just in case
            pool.remove(managedConnection);
            // remove the managed connection from the active connections
            ManagedConnectionEntry entry = (ManagedConnectionEntry)active.remove(managedConnection);    
            
            if (null != entry) {
                // in case the transaction for the entry
                // is changed out from under us 
                synchronized (entry) {
                    // delist the managed connection
                    if (null != entry.transaction) {
                        try {
                            delist(managedConnection, 
                                   entry.transaction,
                                   XAResource.TMFAIL);
                        }
                        finally {
                            entry.resetTransaction();
                        }
                    }
                }
            }
            else if (null != logWriter) {
                logWriter.println( "Internal error: Cannot find the managed entry for the specified managed connection <" +
                                   managedConnection +
                                   "> while trying to dicard the managed connection from the pool " +
                                   "(ManagedConnectionPoolImpl#discard).");
            }
        }
        finally {
            // close the connection
            managedConnection.close();
        }
    }

    /**
     * This object tracks the usage of a managed connection that
     * may be shared. When the managed connection entry is created it is
     * not shared.
     */
    private static class ManagedConnectionEntry
        implements Synchronization
    {

        /**
         * The managed connection
         */
        private final ManagedConnection managedConnection;


        /**
         * The transaction associated with the managed connection
         */
        private Transaction transaction = null;


        /**
         * The number of times a managed connection has been
         * shared. When the reference count reaches 0 the
         * managed conenction can be closed.
         */
        private int refCount = 0;


        /**
         * Create the ManagedConnectionEntry with the specified managed
         * connection which is assumed not to be null.
         *
         * @param managedConnection the managed connection
         * @param transaction the transaction assocaited with the 
         *      managed connection. Can be null.
         */
        private ManagedConnectionEntry(ManagedConnection managedConnection,
                                       Transaction transaction)
            throws IllegalStateException, RollbackException, SystemException
        {
            this.managedConnection = managedConnection;
            setTransaction(transaction);
        }


        /**
         * Set the transaction of the entry to the specified
         * transaction. This method registers the entry as a
         * Synchronization resource to the transaction if it is not
         * null.
         *
         * @param transaction the transaction
         */
        private synchronized void setTransaction(Transaction transaction)
            throws IllegalStateException, RollbackException, SystemException
        {
            if (null == transaction 
                    ? this.transaction != transaction
                    : !transaction.equals(this.transaction)) {
                this.transaction = transaction;
    
                if (null != this.transaction) {
                    this.transaction.registerSynchronization(this);    
                }
            }
        }


        /**
         * Reset the transaction of the entry to null.
         */
        private synchronized void resetTransaction()
        {
            this.transaction = null;
        }

        /**
         * This method is called by the transaction manager 
         * prior to the start of the transaction completion 
         * process. This call is executed with the transaction 
         * context of the transaction that is being committed.
         */
        public void beforeCompletion()
        {
        }


        /**
         * This method is called by the transaction manager 
         * after the transaction is committed or rolled back.
         *
         * @param status - The status of the transaction 
         *      completion.
         */
        public void afterCompletion(int status)
        {
            resetTransaction();
        }


        /**
         * Called by the transaction manager to notify the resource
         * that it had been delisted from the transaction after the
         * transaction has either committed or rolledback.
         */
        /*public void delisted()
        {
            resetTransaction();
        }
        */
    
        /**
         * Called by the transaction manager to notify the resource
         * that it has been enlisted in the specified transaction.
         *
         * @param tx the transaction
         */
        /*public void enlisted(Transaction tx)
        {
            try {
                setTransaction(tx);
            }
            catch (Exception e)
            {
                //RM
            }
        }
        */
    }
}
